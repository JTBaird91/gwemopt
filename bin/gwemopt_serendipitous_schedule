#!/usr/bin/python

# Copyright (C) 2017 Michael Coughlin
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

""".
Gravitational-wave Electromagnetic Optimization

This script generates an optimized list of pointings and content for
reviewing gravitational-wave skymap likelihoods.

Comments should be e-mailed to michael.coughlin@ligo.org.

"""


import os, sys, glob, optparse, shutil, warnings
import copy
import numpy as np
np.random.seed(0)

import healpy as hp
import pandas as pd
from astropy.table import unique, vstack, Table
from astropy import units as u
from astropy.time import Time
from astropy import cosmology
from astropy.coordinates import Distance
from astropy.coordinates import SkyCoord
from astropy.io import fits

import matplotlib
#matplotlib.rc('text', usetex=True)
matplotlib.use('Agg')
matplotlib.rcParams.update({'font.size': 16})
matplotlib.rcParams['contour.negative_linestyle'] = 'solid'
import matplotlib.pyplot as plt
from matplotlib import cm

import ligo.skymap.distance as ligodist

import gwemopt.utils, gwemopt.plotting
import gwemopt.moc, gwemopt.tiles 
import gwemopt.coverage

__author__ = "Michael Coughlin <michael.coughlin@ligo.org>"
__version__ = 1.0
__date__    = "6/17/2017"

# =============================================================================
#
#                               DEFINITIONS
#
# =============================================================================

def parse_commandline():
    """@Parse the options given on the command-line.
    """
    parser = optparse.OptionParser(usage=__doc__,version=__version__)

    parser.add_option("-c", "--configDirectory", help="GW-EM config file directory.", default ="../config/")
    #parser.add_option("-o", "--outputDir", help="output directory",default="../output/S200115j")
    parser.add_option("-i","--inputDir",default="../input/")
    parser.add_option("-o", "--outputDir", help="output directory",default="../output/serendipitous")

    parser.add_option("-t", "--telescope", help="Telescope.", default ="ZTF")
    #parser.add_option("-g", "--gps", help="Event time GPS.", default=1263097398, type=float)
    parser.add_option("-g", "--gps", help="Event time GPS.", default=1240704018, type=float)

    parser.add_option("--Tobs",default="0.0,1.0")

    parser.add_option("--observations", help="observation file.", default='../data/serendipitous/2019-04-25-2019-10-03_subdata.txt')

    parser.add_option("--nside",default=256,type=int)

    parser.add_option("--exposuretimes",default="30.0,30.0")
    parser.add_option("-f","--filters",default="g,r")
    parser.add_option("--max_nb_tiles",default="-1,-1")

    parser.add_option("--doSchedule",  action="store_true", default=False)
    parser.add_option("--doPlots",  action="store_true", default=False)

    parser.add_option("-v", "--verbose", action="store_true", default=False,
                      help="Run verbosely. (Default: False)")

    opts, args = parser.parse_args()

    # show parameters
    if opts.verbose:
        print >> sys.stderr, ""
        print >> sys.stderr, "running gwemopt_run..."
        print >> sys.stderr, "version: %s"%__version__
        print >> sys.stderr, ""
        print >> sys.stderr, "***************** PARAMETERS ********************"
        for o in opts.__dict__.items():
          print >> sys.stderr, o[0]+":"
          print >> sys.stderr, o[1]
        print >> sys.stderr, ""

    return opts

# =============================================================================
#
#                                    MAIN
#
# =============================================================================

warnings.filterwarnings("ignore")

# Parse command line
opts = parse_commandline()

params = {}
params["config"] = {}
configFiles = glob.glob("%s/*.config"%opts.configDirectory)
for configFile in configFiles:
    telescope = configFile.split("/")[-1].replace(".config","")
    if not telescope in opts.telescope.split(","): continue
    params["config"][telescope] = gwemopt.utils.readParamsFromFile(configFile)
    params["config"][telescope]["telescope"] = telescope
    params["config"][telescope]["tesselation"] = np.loadtxt(params["config"][telescope]["tesselationFile"],usecols=(0,1,2),comments='%')
    params["config"][telescope]["tot_obs_time"] = 1.0

    exposuretime = np.array(opts.exposuretimes.split(","),dtype=np.float)[0]

    params["config"][telescope]["magnitude_orig"] = params["config"][telescope]["magnitude"]
    params["config"][telescope]["exposuretime_orig"] = params["config"][telescope]["exposuretime"]

    nmag = np.log(exposuretime/params["config"][telescope]["exposuretime"]) / np.log(2.5)
    params["config"][telescope]["magnitude"] = params["config"][telescope]["magnitude"] + nmag
    params["config"][telescope]["exposuretime"] = exposuretime  

params["outputDir"] = opts.outputDir

if not os.path.isdir(params["outputDir"]):
    os.makedirs(params["outputDir"])

params["tilesType"] = "moc"
params["doMinimalTiling"] = False
params["doParallel"] = False
params["telescopes"] = opts.telescope.split(",")
params["nside"] = opts.nside
params["doChipGaps"] = False
params["doSingleExposure"] = True
params["doAlternatingFilters"] = True
params["doRASlices"] = False
params["doBalanceExposure"] = False
params["powerlaw_n"], params["powerlaw_cl"], params["powerlaw_dist_exp"] = 0.0, 0.9, 0.0
params["gpstime"] = opts.gps
params["Tobs"] = np.array(opts.Tobs.split(","),dtype=np.float)
params["filters"] = opts.filters.split(",")
params["exposuretimes"] = np.array(opts.exposuretimes.split(","),dtype=np.float)
params["doMaxTiles"] = False
params["max_nb_tiles"] = np.array(opts.max_nb_tiles.split(","),dtype=np.float)

npix = hp.nside2npix(opts.nside)
theta, phi = hp.pix2ang(opts.nside, np.arange(npix))
prob_data = np.ones((npix,))
ra = np.rad2deg(phi)
dec = np.rad2deg(0.5*np.pi - theta)
radecs = SkyCoord(ra=ra*u.deg, dec=dec*u.deg)
idx = np.where(np.abs(radecs.galactic.b.deg) <= 10.0)[0]
prob_data[idx] = 0.0
prob_data = prob_data / np.sum(prob_data)

map_struct = {}
map_struct["prob"] = prob_data

sort_idx = np.argsort(map_struct["prob"])[::-1]
csm = np.empty(len(map_struct["prob"]))
csm[sort_idx] = np.cumsum(map_struct["prob"][sort_idx])

map_struct["cumprob"] = csm
map_struct["ipix_keep"] = []
pixarea_deg2 = hp.nside2pixarea(opts.nside, degrees=True)
map_struct["pixarea_deg2"] = pixarea_deg2
map_struct["ra"] = ra
map_struct["dec"] = dec

if opts.doPlots:
    print("Plotting skymap...")
    gwemopt.plotting.skymap(params,map_struct)

params = gwemopt.utils.params_checker(params)

baseoutputDir = params["outputDir"]
if not os.path.isdir(baseoutputDir):
    os.makedirs(baseoutputDir)

Tmin, Tmax, dt = 0, 2, 0.2
Tmax = 0.2
Tobs = np.arange(Tmin, Tmax+dt, dt)

schedulefile = os.path.join(params["outputDir"],'schedule_ZTF.dat')
if not os.path.isfile(schedulefile):
    coverage_structs = []
    for ii in range(len(Tobs)-1):
    
        if np.mod(ii,2) == 0:
            params["filters"] = ["g","r","g","r"]
            params["exposuretimes"] = [120.0,120.0,120.0,120.0]
            params["program_id"] = 2
        else:
            params["filters"] = ["g","r"]
            params["exposuretimes"] = [30.0,30.0]
            params["program_id"] = 1    

        params["outputDir"] = os.path.join(baseoutputDir, "%d" % ii)
        if not os.path.isdir(params["outputDir"]):
            os.makedirs(params["outputDir"])
     
        params["Tobs"] = np.array([Tobs[ii], Tobs[ii+1]])
        params = gwemopt.segments.get_telescope_segments(params)
    
        cnt = 0
        for telescope in params["telescopes"]:
            if not len(params["config"][telescope]["segmentlist"]) == 0:
                cnt = cnt + 1
        if cnt == 0:
            print('Skipping round %.2f-%.2f' % (Tobs[ii], Tobs[ii+1]))
            continue
    
        moc_structs = gwemopt.moc.create_moc(params)
        tile_structs = gwemopt.tiles.moc(params, map_struct, moc_structs)
    
        if opts.doPlots:
            print("Plotting tiles struct...")
            gwemopt.plotting.tiles(params, map_struct, tile_structs)
    
        if opts.doSchedule:
            print("Generating coverage...")
            tile_structs, coverage_struct = gwemopt.coverage.timeallocation(params, map_struct, tile_structs)
    
        if opts.doSchedule:
            print("Summary of coverage...")
            gwemopt.scheduler.summary(params,map_struct,coverage_struct)
    
            if opts.doPlots:
                gwemopt.plotting.coverage(params, map_struct, coverage_struct)
    
        coverage_structs.append(coverage_struct)
    
    coverage_struct = gwemopt.coverage.combine_coverage_structs(coverage_structs)
    params["outputDir"] = baseoutputDir
    if opts.doSchedule:
        print("Summary of coverage...")
        gwemopt.scheduler.summary(params,map_struct,coverage_struct)
    
        if opts.doPlots:
            gwemopt.plotting.coverage(params, map_struct, coverage_struct)

all_obs_table = pd.read_csv(opts.observations, delimiter = '|')
all_obs_table.columns = [c.replace(' ', '') for c in all_obs_table.columns]
use_obs = all_obs_table['status'] == 1
obstable = all_obs_table[use_obs]
obstable['ccdid'] = np.floor(obstable["rcid"]/4)

obsfile = os.path.join(params["outputDir"],'obs.dat')
fid = open(obsfile, 'w')
fid.write('nightdate  |       jd        | field | rcid |        ra0         |       dec0       | nalertpackets | programid |   expid   | fid | scimaglim | diffmaglim | sciinpseeing | difffwhm | exptime | status\n')
fid.write('------------+-----------------+-------+------+--------------------+------------------+---------------+-----------+-----------+-----+-----------+------------+--------------+----------+---------+--------\n')
 
bands = {'g': 1, 'r': 2, 'i': 3, 'z': 4, 'J': 5}   
lines = [line.rstrip('\n') for line in open(schedulefile,'r')]
for line in lines:
    lineSplit = line.split(" ")
    field = int(lineSplit[0])
    mjd = float(lineSplit[3])
    exptime = int(lineSplit[4])
    filter_id = bands[lineSplit[7]]
    program_id = int(lineSplit[8])

    tt = Time(mjd, format='mjd')
    jd = tt.jd

    idx = np.where(field == obstable["field"])[0]
    obstable_field = obstable.iloc[idx]

    idy = np.random.randint(len(obstable_field))
    obstable_row = obstable_field.iloc[[idy]]

    jd = obstable_row["jd"].to_numpy()[0]
    obstable_rows = obstable[obstable["jd"] == jd]

    ttday = tt.isot.split("T")[0]
    for ii, row in obstable_rows.iterrows():
        nmag = np.log(exptime/row.exptime)/np.log(2.5)
        print(nmag)
        fid.write('%s | %.7f |   %d |   %d |      %.9f |  %.11f |             %d |         %d |  %d |   %d |     %.2f |    %.4f |       %.4f |  %.5f |      %d |      %d\n' %(ttday, jd, field, int(row.rcid), row.ra0, row.dec0, int(row.nalertpackets), program_id, int(row.expid), filter_id, row.scimaglim + nmag, row.diffmaglim + nmag, row.sciinpseeing, row.difffwhm, exptime, int(row.status)))
fid.close()

print(stop)

# init figure
fig1 = plt.figure(figsize=(14,8))

# background setup
NSIDE = 256
NPIX = hp.nside2npix(NSIDE)
coordsys = ['C','C']
nest = True

# colormap
cm = plt.cm.get_cmap('viridis') # colorscale
cm.set_under('w')
cm.set_bad('w')

# load the data
hdulist = fits.open(opts.inputDir+'Gaia_hp8_densitymap.fits')
hist = hdulist[1].data['srcdens'][np.argsort(hdulist[1].data['hpx8'])]

# plot the data in healpy
norm ='log'
hp.mollview(hist,fig=1,norm=norm,unit='Stars per sq. arcmin.',cbar=False,nest=nest,title='',coord=coordsys,notext=True,cmap=cm,flip='astro',nlocs=4)

# borders
lw = 3
pi = np.pi
dtor = pi/180.
theta = np.arange(0,181)*dtor
hp.projplot(theta, theta*0-pi,'-k',
                               lw=lw,direct=True)
hp.projplot(theta, theta*0+0.9999*pi,'-k',
                               lw=lw,direct=True)
phi = np.arange(-180,180)*dtor
hp.projplot(phi*0+1.e-10, phi,'-k',
                               lw=lw,direct=True)
hp.projplot(phi*0+pi-1.e-10, phi,'-k',
                               lw=lw,direct=True)

# galaxy
for gallat in [15,0,-15]:
    theta = np.arange(0., 360, 0.036)
    phi = gallat*np.ones_like(theta)
    hp.projplot(theta, phi, 'w-', coord=['G'],lonlat=True,lw=2)

# ecliptic
for ecllat in zip([0,-30,30],[2,1,1]):
    theta = np.arange(0., 360, 0.036)
    phi = gallat*np.ones_like(theta)
    hp.projplot(theta, phi, 'w-', coord=['E'],lonlat=True,lw=2,ls=':')

# graticule
hp.graticule(ls='-',alpha=0.1,lw=0.5)

# NWES
fig = plt.gcf()
ax = plt.gca()
plt.text(0.0,0.5,r'E',ha='right',transform=ax.transAxes,weight='bold')
plt.text(1.0,0.5,r'W',ha='left',transform=ax.transAxes,weight='bold')
plt.text(0.5,0.992,r'N',va='bottom',ha='center',transform=ax.transAxes,weight='bold')
plt.text(0.5,0.0,r'S',va='top',ha='center',transform=ax.transAxes,weight='bold')

for telescope in params["telescopes"]:
    config_struct = params["config"][telescope]
    moc_struct = moc_structs[telescope]

    fields = moc_struct.keys()
    for field in fields:
        print(field)
        if field < 246: continue
        ra, dec = moc_struct[field]["ra"], moc_struct[field]["dec"]

        coords = moc_struct[field]["corners"]
        coords = SkyCoord(np.squeeze(coords), unit='deg')
        #ax.plot(coords.ra, coords.dec, color='k', transform=ax.transAxes, zorder=500)
        color = 'k'
        hp.projplot(coords.ra, coords.dec, color,
                    coord=coordsys,lonlat=True,lw=2,alpha=0.5)

        hp.projtext(ra, dec,
                    s='%d'%field, text='%d'%field,
                    coord=coordsys,
                    lonlat=True,
                    fontsize=8,
                    color='k',zorder=700,
                    ha='center',va='center')

plt.show()
plotName = os.path.join(params["outputDir"],'coverage.pdf')
plt.savefig(plotName)
plt.close()

