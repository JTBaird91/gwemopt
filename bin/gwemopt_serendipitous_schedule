#!/usr/bin/python

# Copyright (C) 2017 Michael Coughlin
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

""".
Gravitational-wave Electromagnetic Optimization

This script generates an optimized list of pointings and content for
reviewing gravitational-wave skymap likelihoods.

Comments should be e-mailed to michael.coughlin@ligo.org.

"""


import os, sys, glob, optparse, shutil, warnings
import copy
import numpy as np
np.random.seed(0)

import healpy as hp
import pandas as pd
from astropy.table import unique, vstack, Table
from astropy import units as u
from astropy.time import Time
from astropy import cosmology
from astropy.coordinates import Distance
from astropy.coordinates import SkyCoord
from astropy.io import fits

import matplotlib
#matplotlib.rc('text', usetex=True)
matplotlib.use('Agg')
matplotlib.rcParams.update({'font.size': 16})
matplotlib.rcParams['contour.negative_linestyle'] = 'solid'
from matplotlib import patches
from matplotlib.colors import LogNorm
import matplotlib.pyplot as plt
from matplotlib import cm

import ligo.skymap.distance as ligodist

import gwemopt.utils, gwemopt.plotting
import gwemopt.moc, gwemopt.tiles 
import gwemopt.coverage

__author__ = "Michael Coughlin <michael.coughlin@ligo.org>"
__version__ = 1.0
__date__    = "6/17/2017"

# =============================================================================
#
#                               DEFINITIONS
#
# =============================================================================

def parse_commandline():
    """@Parse the options given on the command-line.
    """
    parser = optparse.OptionParser(usage=__doc__,version=__version__)

    parser.add_option("-c", "--configDirectory", help="GW-EM config file directory.", default ="../config/")
    #parser.add_option("-o", "--outputDir", help="output directory",default="../output/S200115j")
    parser.add_option("-i","--inputDir",default="../input/")
    parser.add_option("-o", "--outputDir", help="output directory",default="../output/serendipitous")

    parser.add_option("-t", "--telescope", help="Telescope.", default ="ZTF")
    #parser.add_option("-g", "--gps", help="Event time GPS.", default=1263097398, type=float)
    parser.add_option("-g", "--gps", help="Event time GPS.", default=1240704018, type=float)

    parser.add_option("--Tobs",default="0.0,1.0")

    parser.add_option("--Tmin",default=0.0,type=float)
    parser.add_option("--Tmax",default=60.0,type=float)
    parser.add_option("--dt",default=0.2,type=float)

    parser.add_option("--observations", help="observation file.", default='../data/serendipitous/ztf_obsfile_status1_backfill_v2_0501_0901.csv')

    parser.add_option("--nside",default=256,type=int)

    parser.add_option("--exposuretimes",default="30.0,30.0")
    parser.add_option("-f","--filters",default="g,r")
    parser.add_option("--max_nb_tiles",default="-1,-1")

    parser.add_option("--downsample",default=1,type=int)

    parser.add_option("--doSchedule",  action="store_true", default=False)
    parser.add_option("--doPlots",  action="store_true", default=False)
    parser.add_option("--doMovie",  action="store_true", default=False)

    parser.add_option("-v", "--verbose", action="store_true", default=False,
                      help="Run verbosely. (Default: False)")

    opts, args = parser.parse_args()

    # show parameters
    if opts.verbose:
        print >> sys.stderr, ""
        print >> sys.stderr, "running gwemopt_run..."
        print >> sys.stderr, "version: %s"%__version__
        print >> sys.stderr, ""
        print >> sys.stderr, "***************** PARAMETERS ********************"
        for o in opts.__dict__.items():
          print >> sys.stderr, o[0]+":"
          print >> sys.stderr, o[1]
        print >> sys.stderr, ""

    return opts

# =============================================================================
#
#                                    MAIN
#
# =============================================================================

warnings.filterwarnings("ignore")

# Parse command line
opts = parse_commandline()

params = {}
params["config"] = {}
configFiles = glob.glob("%s/*.config"%opts.configDirectory)
for configFile in configFiles:
    telescope = configFile.split("/")[-1].replace(".config","")
    if not telescope in opts.telescope.split(","): continue
    params["config"][telescope] = gwemopt.utils.readParamsFromFile(configFile)
    params["config"][telescope]["telescope"] = telescope
    params["config"][telescope]["tesselation"] = np.loadtxt(params["config"][telescope]["tesselationFile"],usecols=(0,1,2),comments='%')
    params["config"][telescope]["tot_obs_time"] = 1.0

    exposuretime = np.array(opts.exposuretimes.split(","),dtype=np.float)[0]

    params["config"][telescope]["magnitude_orig"] = params["config"][telescope]["magnitude"]
    params["config"][telescope]["exposuretime_orig"] = params["config"][telescope]["exposuretime"]

    nmag = np.log(exposuretime/params["config"][telescope]["exposuretime"]) / np.log(2.5)
    params["config"][telescope]["magnitude"] = params["config"][telescope]["magnitude"] + nmag
    params["config"][telescope]["exposuretime"] = exposuretime  

params["outputDir"] = opts.outputDir
if not os.path.isdir(params["outputDir"]):
    os.makedirs(params["outputDir"])
baseoutputDir = params["outputDir"]

params["tilesType"] = "moc"
params["doMinimalTiling"] = False
params["doParallel"] = False
params["telescopes"] = opts.telescope.split(",")
params["nside"] = opts.nside
params["doChipGaps"] = False
params["doSingleExposure"] = True
params["doAlternatingFilters"] = True
params["doRASlices"] = False
params["doBalanceExposure"] = True
params["powerlaw_n"], params["powerlaw_cl"], params["powerlaw_dist_exp"] = 0.0, 0.9, 0.0
params["gpstime"] = opts.gps
params["Tobs"] = np.array(opts.Tobs.split(","),dtype=np.float)
params["filters"] = opts.filters.split(",")
params["exposuretimes"] = np.array(opts.exposuretimes.split(","),dtype=np.float)
params["doMaxTiles"] = False
params["doUsePrimary"] = True
params["scheduleType"] = "greedy_slew"
params["airmass"] = 2.0
params["max_nb_tiles"] = np.array(opts.max_nb_tiles.split(","),dtype=np.float)

mjd0 = Time(opts.gps, format='gps').mjd

npix = hp.nside2npix(opts.nside)
theta, phi = hp.pix2ang(opts.nside, np.arange(npix))
prob_data = np.ones((npix,))
prob_data = prob_data / np.sum(prob_data)
ra = np.rad2deg(phi)
dec = np.rad2deg(0.5*np.pi - theta)
radecs = SkyCoord(ra=ra*u.deg, dec=dec*u.deg)

map_struct_1 = {}
map_struct_1["prob"] = prob_data

sort_idx = np.argsort(map_struct_1["prob"])[::-1]
csm = np.empty(len(map_struct_1["prob"]))
csm[sort_idx] = np.cumsum(map_struct_1["prob"][sort_idx])

map_struct_1["cumprob"] = csm
map_struct_1["ipix_keep"] = []
pixarea_deg2 = hp.nside2pixarea(opts.nside, degrees=True)
map_struct_1["pixarea_deg2"] = pixarea_deg2
map_struct_1["ra"] = ra
map_struct_1["dec"] = dec

if opts.doPlots:
    params["outputDir"] = os.path.join(baseoutputDir, "map_1")
    if not os.path.isdir(params["outputDir"]):
        os.makedirs(params["outputDir"])
    print("Plotting skymap...")
    gwemopt.plotting.skymap(params,map_struct_1)

prob_data = np.ones((npix,))
prob_data = prob_data / np.sum(prob_data)
idx = np.where(np.abs(radecs.galactic.b.deg) <= 10.0)[0]
prob_data[idx] = 0.0
prob_data = prob_data / np.sum(prob_data)

map_struct_2 = {}
map_struct_2["prob"] = prob_data

sort_idx = np.argsort(map_struct_2["prob"])[::-1]
csm = np.empty(len(map_struct_2["prob"]))
csm[sort_idx] = np.cumsum(map_struct_2["prob"][sort_idx])

map_struct_2["cumprob"] = csm
map_struct_2["ipix_keep"] = []
pixarea_deg2 = hp.nside2pixarea(opts.nside, degrees=True)
map_struct_2["pixarea_deg2"] = pixarea_deg2
map_struct_2["ra"] = ra
map_struct_2["dec"] = dec

params = gwemopt.utils.params_checker(params)
moc_structs = gwemopt.moc.create_moc(params)

map_struct = map_struct_1

Tmin, Tmax, dt = opts.Tmin, opts.Tmax, opts.dt
Tobs = np.arange(Tmin, Tmax+dt, dt)

params["outputDir"] = baseoutputDir
schedulefile = os.path.join(params["outputDir"],'schedule_ZTF.dat')

if not os.path.isfile(schedulefile):
    coverage_structs = []
    for ii in range(len(Tobs)-1):
        print('Running block %d/%d' % (ii, len(Tobs)-1))  
 
        params["outputDir"] = os.path.join(baseoutputDir, "%d" % ii)
        if not os.path.isdir(params["outputDir"]):
            os.makedirs(params["outputDir"])

        schedulefileind = os.path.join(params["outputDir"],'schedule_ZTF.dat')
        if os.path.isfile(schedulefileind):
            moc_struct = moc_structs["ZTF"]
            coverage_struct = gwemopt.coverage.read_coverage(params, "ZTF",
                                                             schedulefileind,
                                                             moc_struct=moc_struct)
        else:
            if np.mod(ii,2) == 1:
                schedule_table = pd.read_csv(schedulefile, 
                                             delimiter = ' ', header=None,
                                             names = ('field', 'ra', 'dec',
                                                      'mjd', 'mag',
                                                      'exposure_time', 'prob',
                                                      'airmass', 'filt',
                                                      'program_id'))
                idx = np.where((schedule_table['mjd'] >= (mjd0+Tobs[ii]-7.0)) &
                               (schedule_table['mjd'] <= (mjd0+Tobs[ii])))[0]
                schedule_table_field = schedule_table.iloc[idx]
    
                if len(schedule_table_field) > 0:
                    prob_data = np.zeros((npix,))
                    for jj, row2 in schedule_table_field.iterrows():
                        field = row2["field"]
                        if not field in moc_structs["ZTF"]: continue
                        moc_struct = moc_structs["ZTF"][field]
                        ipix = moc_struct["ipix"]
                        prob_data[ipix] = 1.0
                        dt = mjd0 + Tobs[ii] - row2["mjd"]
                        prob_data[ipix] = np.exp(-dt)
                    prob_data[prob_data < 0.01] = 0.01
                    idx = np.where(np.abs(radecs.galactic.b.deg) <= 10.0)[0]
                    prob_data[idx] = 0.0
                    prob_data = prob_data / np.sum(prob_data)
                else:
                    prob_data = np.ones((npix,))            
                    idx = np.where(np.abs(radecs.galactic.b.deg) <= 10.0)[0]
                    prob_data[idx] = 0.0
                    prob_data = prob_data / np.sum(prob_data)
    
                map_struct_2["prob"] = prob_data
                
                sort_idx = np.argsort(map_struct_2["prob"])[::-1]
                csm = np.empty(len(map_struct_2["prob"]))
                csm[sort_idx] = np.cumsum(map_struct_2["prob"][sort_idx])
                
                map_struct_2["cumprob"] = csm
    
                map_struct = map_struct_2
                params["filters"] = ["g","r"]
                params["exposuretimes"] = [180.0,180.0]
                params["program_id"] = 2
    
                params["doBlocks"] = False
                params["Nblocks"] = 2
    
                if opts.doPlots:
                    print("Plotting skymap...")
                    gwemopt.plotting.skymap(params,map_struct_2)
            else:
                if os.path.isfile(schedulefile):
                    prob_data = np.ones((npix,))
    
                    schedule_table = pd.read_csv(schedulefile,
                                                 delimiter = ' ', header=None,
                                                 names = ('field', 'ra', 'dec',
                                                          'mjd', 'mag',
                                                          'exposure_time', 'prob',
                                                          'airmass', 'filt',
                                                          'program_id'))
                    idx = np.where((schedule_table['mjd'] >= (mjd0+Tobs[ii]-7.0)) &
                                   (schedule_table['mjd'] <= (mjd0+Tobs[ii])))[0]
                    schedule_table_field = schedule_table.iloc[idx]
    
                    for jj, row2 in schedule_table_field.iterrows():
                        field = row2["field"]
                        if not field in moc_structs["ZTF"]: continue
                        moc_struct = moc_structs["ZTF"][field]
                        ipix = moc_struct["ipix"]
                        dt = mjd0 + Tobs[ii] - row2["mjd"]
                        prob_data[ipix] = 1.0 - np.exp(-dt)
                    prob_data = prob_data / np.sum(prob_data)
                else:
                    prob_data = np.ones((npix,))
                    prob_data = prob_data / np.sum(prob_data)
    
                map_struct_1["prob"] = prob_data
    
                sort_idx = np.argsort(map_struct_1["prob"])[::-1]
                csm = np.empty(len(map_struct_1["prob"]))
                csm[sort_idx] = np.cumsum(map_struct_1["prob"][sort_idx])
    
                map_struct_1["cumprob"] = csm
    
                map_struct = map_struct_1
                params["filters"] = ["g","r"]
                params["exposuretimes"] = [30.0,30.0]
                params["program_id"] = 1    
    
                params["doBlocks"] = True
                params["Nblocks"] = 2
    
            params["Tobs"] = np.array([Tobs[ii], Tobs[ii+1]])
            params = gwemopt.segments.get_telescope_segments(params)
    
            cnt = 0
            for telescope in params["telescopes"]:
                if not len(params["config"][telescope]["segmentlist"]) == 0:
                    cnt = cnt + 1
            if cnt == 0:
                print('Skipping round %.2f-%.2f' % (Tobs[ii], Tobs[ii+1]))
                continue
        
            moc_structs = gwemopt.moc.create_moc(params)
            tile_structs = gwemopt.tiles.moc(params, map_struct, moc_structs)
        
            if opts.doPlots:
                print("Plotting tiles struct...")
                gwemopt.plotting.tiles(params, map_struct, tile_structs)
        
            if opts.doSchedule:
                print("Generating coverage...")
                tile_structs, coverage_struct = gwemopt.coverage.timeallocation(params, map_struct, tile_structs)
        
            if opts.doSchedule:
                print("Summary of coverage...")
                gwemopt.scheduler.summary(params,map_struct,coverage_struct)
        
                if opts.doPlots:
                    gwemopt.plotting.coverage(params, map_struct, coverage_struct)
    
        coverage_structs.append(coverage_struct)

        coverage_struct_combined = gwemopt.coverage.combine_coverage_structs(coverage_structs)
        params["outputDir"] = baseoutputDir
        if opts.doSchedule:
            print("Summary of coverage...")
            gwemopt.scheduler.summary(params,map_struct,coverage_struct_combined)
    
            if opts.doPlots:
                if (np.mod(ii, 15) == 0) or (ii == len(Tobs)-2):
                    gwemopt.plotting.coverage(params, map_struct, coverage_struct_combined)

if opts.doMovie:

    # load the data
    hdulist = fits.open(opts.inputDir+'Gaia_hp8_densitymap.fits')
    hist = hdulist[1].data['srcdens'][np.argsort(hdulist[1].data['hpx8'])]

    bands = {'g': 1, 'r': 2, 'i': 3, 'z': 4, 'J': 5}   
    schedule_table = pd.read_csv(schedulefile, delimiter = ' ', header=None,
                                 names = ('field', 'ra', 'dec', 'mjd',
                                          'exposure_time', 'prob', 
                                          'airmass', 'filt', 'program_id'))

    #schedule_table = schedule_table[:100]
    gfields, rfields, grfields = [], [], []
    for ii, row1 in schedule_table.iterrows():
        idx = np.where((schedule_table['mjd'] >= row1['mjd']-1.0) &
                       (schedule_table['mjd'] <= row1['mjd']))[0]
        schedule_table_field = schedule_table.iloc[idx]

        idx = np.where(schedule_table_field["filt"] == "g")[0]
        schedule_table_field_g = schedule_table_field.iloc[idx]

        idx = np.where(schedule_table_field["filt"] == "r")[0]
        schedule_table_field_r = schedule_table_field.iloc[idx]

        gfield = np.unique(schedule_table_field_g["field"])
        rfield = np.unique(schedule_table_field_r["field"])    
        grfield = np.intersect1d(gfield,rfield)

        gfields.append(len(gfield))
        rfields.append(len(rfield))
        grfields.append(len(grfield))

    schedule_table["gfields"] = gfields
    schedule_table["rfields"] = rfields
    schedule_table["grfields"] = grfields

    moc_structs = gwemopt.moc.create_moc(params)
    moc_structs = moc_structs["ZTF"]

    moviedir = os.path.join(baseoutputDir,'movie')
    if not os.path.isdir(moviedir):
        os.makedirs(moviedir)

    cnt = 0 
    for ii, row1 in schedule_table.iterrows():
        plotName = os.path.join(moviedir,'movie-%04d.png'%cnt)
        if os.path.isfile(plotName):
            cnt = cnt + 1
            continue
        if not np.mod(ii,opts.downsample) == 0: continue

        fig = plt.figure(figsize=(12, 8))

        gs = fig.add_gridspec(4, 1)
        ax1 = fig.add_subplot(gs[0:3, 0], projection='astro hours mollweide')
        ax2 = fig.add_subplot(gs[3, 0])

        plt.axes(ax1)
        # plot the data in healpy
        norm ='log'

        ax1.imshow_hpx(hist, cmap='viridis', norm=LogNorm(), nested=True)
        ax1.grid()

        ra = ax1.coords[0]
        dec = ax1.coords[1]

        ra.set_ticks_visible(False)
        dec.set_ticks_visible(False)

        for jj, row2 in schedule_table.iterrows():
            if ii < jj: continue
            dt = row1["mjd"] - row2["mjd"]
            if dt > 2: continue

            field = row2["field"]
            if not field in moc_structs: continue
            moc_struct = moc_structs[field]
            ras, decs = moc_struct["corners"][:,0], moc_struct["corners"][:,1]
            if len(ras) == 4:
                ras = [ras[0], ras[1], ras[3], ras[2], ras[0]]
                decs = [decs[0], decs[1], decs[3], decs[2], decs[0]]
                ras, decs = np.array(ras), np.array(decs)
            if row2['filt'] == 'g':
                color = 'g'
            elif row2['filt'] == 'r':
                color = 'r'
            else:
                color = 'k'

            idx = np.where((schedule_table['mjd'] >= row1['mjd']-2.0) &
                           (schedule_table['mjd'] <= row1['mjd']) &
                           (schedule_table['field'] == field))[0]
            schedule_table_field = schedule_table.iloc[idx]

            idx = np.where(schedule_table_field["filt"] == "g")[0]
            schedule_table_field_g = schedule_table_field.iloc[idx]

            idx = np.where(schedule_table_field["filt"] == "r")[0]
            schedule_table_field_r = schedule_table_field.iloc[idx]

            if ii == jj:
                alpha = 1.0
                linewidth = 3.0

                idx1, idx2 = np.where(ras>=180.0)[0], np.where(ras<180.0)[0]
                idx3, idx4 = np.where(ras>300.0)[0], np.where(ras<60.0)[0]
                if (len(idx1)>0 and len(idx2)>0) and not (len(idx3)>0 and len(idx4)>0):
                    alpha = 0.0

                poly = patches.Polygon(np.vstack((ras, decs)).T, transform=ax1.get_transform('world'), alpha=alpha, color=color)
                ax1.plot(ras, decs, color=color, transform=ax1.get_transform('world'), alpha=alpha, linewidth=linewidth)
                ax1.add_patch(poly)
            else:
                alpha = 0.5*(2-dt)*0.5
                linewidth = 2.0*(2-dt)*0.5

                idx1, idx2 = np.where(ras>=180.0)[0], np.where(ras<180.0)[0]
                idx3, idx4 = np.where(ras>300.0)[0], np.where(ras<60.0)[0]
                if (len(idx1)>0 and len(idx2)>0) and not (len(idx3)>0 and len(idx4)>0):
                    alpha = 0.0

                if (len(schedule_table_field_g) > 0) and (len(schedule_table_field_r) > 0):
                    color='magenta'
                poly = patches.Polygon(np.vstack((ras, decs)).T, transform=ax1.get_transform('world'), alpha=alpha, color=color)
                ax1.plot(ras, decs, color=color, transform=ax1.get_transform('world'), alpha=alpha, linewidth=linewidth)
                ax1.add_patch(poly)

        idx = np.where(schedule_table['mjd'] <= row1['mjd'])[0]
        schedule_table_field = schedule_table.iloc[idx]

        ax2.plot(schedule_table_field["mjd"]-mjd0, schedule_table_field["gfields"],
                 '-', color='g',label='g-band')
        ax2.plot(schedule_table_field["mjd"]-mjd0, schedule_table_field["rfields"],
                 '--', color='r',label='r-band')
        ax2.plot(schedule_table_field["mjd"]-mjd0, schedule_table_field["grfields"],
                 ':', color='magenta',label='g+r-bands')
        ax2.legend(loc=1)
        ax2.set_xlabel('Days since MJD=%.5f' % mjd0)
        ax2.set_ylabel('Fields observed last 24 hrs')

        ax2.set_xlim([np.min(schedule_table['mjd'])-mjd0,
                      np.max(schedule_table['mjd'])-mjd0])
        max_area = np.max([np.max(schedule_table['gfields']),
                           np.max(schedule_table['rfields']),
                           np.max(schedule_table['grfields'])])
        ax2.set_ylim([0,max_area])
        fig.suptitle('')

        plotName = os.path.join(moviedir,'movie-%04d.png'%cnt)
        plt.savefig(plotName,dpi=200,bbox_inches='tight')
        plt.close()

        cnt = cnt + 1

    output = "schedule"
    moviefiles = os.path.join(moviedir,"movie-%04d.png")
    filename = os.path.join(moviedir,"%s.mpg" % (output))
    ffmpeg_command = 'ffmpeg -an -y -r 20 -i %s -b:v %s %s'%(moviefiles,'5000k',filename)
    os.system(ffmpeg_command)
    filename = os.path.join(moviedir,"%s.gif" % (output))
    ffmpeg_command = 'ffmpeg -an -y -r 20 -i %s -b:v %s %s'%(moviefiles,'5000k',filename)
    os.system(ffmpeg_command)
    rm_command = "rm %s/*.png"%(moviedir)
    os.system(rm_command)

all_obs_table = pd.read_csv(opts.observations, delimiter = ',')
use_obs = all_obs_table['status'] == 1
obstable = all_obs_table[use_obs]

params["outputDir"] = baseoutputDir

obsfile = os.path.join(params["outputDir"],'obs.dat')
fid = open(obsfile, 'w')
fid.write('jd,fieldid,chid,progid,expid,filterid,limMag,status\n')
 
bands = {'g': 1, 'r': 2, 'i': 3, 'z': 4, 'J': 5}   
schedule_table = pd.read_csv(schedulefile, delimiter = ' ', header=None,
                             names = ('field', 'ra', 'dec',
                                      'mjd', 'mag',
                                      'exposure_time', 'prob',
                                      'airmass', 'filt', 'program_id'))

for ii, row1 in schedule_table.iterrows():
    field = row1["field"]
    mjd = row1["mjd"]
    exptime = row1["exposure_time"]
    filt = row1["filt"]
    filter_id = bands[filt]
    program_id = row1["program_id"]

    tt = Time(mjd, format='mjd')
    jd = tt.jd

    obstable_field = []
    cnt = 0
    while len(obstable_field) == 0:
        idx = np.where(field-cnt == obstable["fieldid"])[0]
        obstable_field = obstable.iloc[idx]
        if len(obstable_field) == 0:
            print('No data for field %d...' % (field-cnt))
            cnt = cnt+1

    idy = np.random.randint(len(obstable_field))
    obstable_row = obstable_field.iloc[[idy]]
    obstable_rows = obstable[obstable["jd"] == obstable_row["jd"].to_numpy()[0]]

    for ii, row in obstable_rows.iterrows():
        # FIXME
        #nmag = np.log(exptime/row.exptime)/np.log(2.5)
        nmag = np.log(exptime/30.0)/np.log(2.5)

        fid.write('%.7f, %d, %d, %d, %d, %d, %.2f, %d\n'%(jd, field, int(row.chid), program_id, int(row.expid), filter_id, row.limMag+nmag, int(row.status)))
fid.close()

